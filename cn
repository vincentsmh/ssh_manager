#/bin/bash

# Color function
# Parameters:
#    - $1: color number
#    - $2: message
#    - $3: newline
function color_msg
{
	echo -e $3 "\033[1;$1m$2\033[0m"
}

function check_n_exit()
{
	if [ ! $1 -eq 0 ]; then
		color_msg 31 "$2"

		exit 1
	fi
}

# Read all sites data into 'sites'
function read_sites()
{
	num_of_sites=0

	while read site
	do
		th=$(echo $site | awk -F "_" {'print $1'} | awk -F "node" {'print $2'})
		sites[$th]=$site
		num_of_sites=$(($num_of_sites+1))
	done < $HOME/conn.data
}

function export_to_file()
{
	rm -rf $HOME/conn.data

	for site in "${sites[@]}"
	do
		echo $site
	done > $HOME/conn.data
}

# Check if the given node exists in conn.data. If not, exit with error code 1.
# Input:
#   $1: site number
#   $2: exit if the site number is not existed.
# Return:
#   -1: does not exist
#   >0: index
function is_site_exist()
{
	# Check if the node is existed.
	i=1
	check=0

	for site in "${sites[@]}"
	do
		check=$(echo $site | grep -c node$1)

		if [ "$check" != "0" ]; then
			break
		fi

		i=$(($i+1))
	done

	if [ "$check" == "0" ]; then
		return -1
	else
		return $i
	fi
}

# Parse conn.data to retrieve node's IP according to the given node number
function find_ip()
{
	is_site_exist $1
	index=$?

	if [ $index -eq -1 ]; then
		return 1
	fi

	cmd="echo ${sites[$index]} | awk -F \"_\" {'print \$2'} | awk -F \"@\" {'print \$2'}"
	ip=$(eval $cmd)
	echo $ip
}

# Parse conn.data to retrieve user according to the given node number
function find_user()
{
	is_site_exist $1
	index=$?

	if [ $index -eq -1 ]; then
		return 1
	fi

	cmd="echo ${sites[$index]} | awk -F \"_\" {'print \$2'} | awk -F \"@\" {'print \$1'}"
	user=$(eval $cmd)
	echo $user
}

# Parse conn.data to retrieve the node which is user@ip.
function find_userip()
{
	if [ "${sites[$1]}" == "" ]; then
		return 1
	fi

	userip=`echo "${sites[$1]}" | grep node$1_ | awk -F "_" {'print $2'}`
	echo $userip
	return 0
}

function get_maxlen()
{
	DEFAULT_ID_LEN=3
	DEFAULT_USERIP_LEN=7
	DEFAULT_DESCRIPT_LEN=11
	max_userip_len=0
	max_id_len=0
	max_desc_len=0

	for site in "${sites[@]}"
	do
		len_userip=`echo $site | awk -F "_" {'print $2'} | wc -c`
		len_id=`echo $site | awk -F "_" {'print $1'} | awk -F "node" {'print $2'} | wc -c`
		len_desc=`echo $site | awk -F "_" {'print $3'} | wc -c`

		if [ $len_userip -gt $max_userip_len ]; then
			max_userip_len=$len_userip
		fi

		if [ $len_id -gt $max_id_len ]; then
			max_id_len=$len_id
		fi

		if [ $len_desc -gt $max_desc_len ]; then
			max_desc_len=$len_desc
		fi
	done

	if [ $DEFAULT_ID_LEN -gt $max_id_len ]; then
		max_id_len = $DEFAULT_ID_LEN
	fi

	if [ $DEFAULT_USERIP_LEN -gt $max_userip_len ]; then
		max_userip_len = $DEFAULT_USERIP_LEN
	fi

	if [ $DEFAULT_DESCRIPT_LEN -gt $max_desc_len ]; then
		max_desc_len = $DEFAULT_DESC_LEN
	fi

	return 0
}

function get_space()
{
	len=$(echo $1 | wc -c)
	space_len=$(($2 - $len))

	if [ $space_len -eq 0 ]; then
		echo " "
		return 0
	fi

	space=" "
	for ((i=0;i<$space_len;i++))
	do
		space=$(echo "$space ")
	done

	echo "$space"
}

function print_dash()
{
	echo -n "+"
	for ((i=0;i<=$1;i++))
	do
		echo -n "-"
	done
	echo -n "+"

	for ((i=0;i<=$2;i++))
	do
		echo -n "-"
	done
	echo -n "+"

	for ((i=0;i<=$3;i++))
	do
		echo -n "-"
	done
	echo "+"
}

# Print table's head and tail
# Input:
#   $1->option: head/tail
#   $1->max_id_len
#   $2->max_userip_len
#   $3->max_desc_len
function print_head_tail()
{
	TITLE_NUM="NO"
	TITLE_USERIP="user@IP"
	TITLE_DESCRIPT="Description"

	print_dash $2 $3 $4

	if [ "$1" == "head" ];then
		space_id=$(get_space "$TITLE_NUM" $max_id_len)
		space_userip=$(get_space "$TITLE_USERIP" $max_userip_len)
		space_desc=$(get_space "$TITLE_DESCRIPT" $max_desc_len)

		color_msg 37 "| " -n
		color_msg 37 "$TITLE_NUM$space_id" -n
		color_msg 37 "| " -n
		color_msg 37 "$TITLE_USERIP$space_userip" -n
		color_msg 37 "| " -n
		color_msg 37 "$TITLE_DESCRIPT$space_desc" -n
		color_msg 37 "|"

		print_dash $2 $3 $4
	fi

}

# Display all of the remote sites defined in conn.data
function display_site()
{

	# If no data file, touch an empty one.
	touch $HOME/conn.data
	color=32

	get_maxlen

	# Print table head
	print_head_tail "head" $max_id_len $max_userip_len $max_desc_len

	for site in "${sites[@]}"
	do
		nodeNUM=`echo $site | awk -F "_"  {'print $1'} | awk -F "node" {'print $2'}`
		nodeName=`echo $site | awk -F "_" {'print $3'}`
		nodeUserIP=`echo $site | awk -F "_" {'print $2'}`
		space_id=$(get_space "$nodeNUM" $max_id_len)
		space_userip=$(get_space "$nodeUserIP" $max_userip_len)
		space_desc=$(get_space "$nodeName" $max_desc_len)

		color_msg 37 "| " -n
		color_msg $color "$nodeNUM$space_id" -n
		color_msg 37 "| " -n
		color_msg $color "$nodeUserIP$space_userip" -n
		color_msg 37 "| " -n
		color_msg $color "$nodeName$space_desc" -n
		color_msg 37 "|"
		color=$((color+1))
		if [ $color -eq 38 ]; then
			color=32
		fi
	done

	print_head_tail "tail" $max_id_len $max_userip_len $max_desc_len
	echo -e
}

function display_scp()
{
	color_msg 38 "   - " -n
	color_msg 32 "s" -n
	color_msg 38 ": scp a file/directory to the given site. "
	color_msg 38 "        ex: cn s file 3"
}

# Secure copy file to the remote site.
function scp_function()
{
	if [ -z $1 ] || [ -z $2 ]; then
		display_scp
		exit 0
	fi

	file=$2
	shift 2

	for node in $@
	do
		userip=$(find_userip $node)
		check_n_exit $? "[$node] does not exist"
		scp -r $file $userip:~
	done

	if [ $? -eq 0 ]; then
		color_msg 32 "Copy file successfull."
	else
		color_msg 31 "Copy file failed."
	fi
}


function find_regkeybin()
{
	bin=$(whereis regkey.py | awk {'print $2'})

	if [ "$bin" == "" ]; then
		bin=$(whereis regkey.py)
	fi

	if [ "$bin" == "" ]; then
		return 1
	fi

	echo $bin
	return 0
}


# This function will regiester local's public key (id_rsa.pub) to the remote site.
function reg_key()
{
	if [ -z $1 ] || [ -z $2 ]; then
		color_msg 32 "Register public key to the remote site"
		color_msg 32 "Usage: conn r num pwd"
		color_msg 32 "   - num: the number of the site"
		color_msg 32 "   - pwd: the password to login the remote site"
		exit 0
	fi

	# Check if have id_rsa.pub
	pk="$HOME/.ssh/id_rsa.pub"
	if [ ! -f $pk ]; then
		color_msg 31 "No public key found. Please generate your key-pair first."
		exit 0
	fi

	ip=$(find_ip "$1")
	check_n_exit $? "[$1] does not exist."
	user=$(find_user "$1")
	check_n_exit $? "[$1] does not exist."

	reg_bin=$(find_regkeybin)

	if [ ! $? -eq 0 ]; then
		color_msg 31 "Cannot find regkey.py."
		exit 1
	fi

	python $reg_bin $ip $user $2 $pk

	if [ $? -eq 0 ]; then
		echo -e
		color_msg 32 "Register public key to $ip successfully."
	else
		echo -e
		color_msg 31 "Register public key to $ip failed."
	fi
}

function add_node_to_num()
{
	add_site="node$1_$2_$3"
	sites[$1]=$add_site
	export_to_file
}

# Read suitable number for insertion.
function find_insert_num()
{
	i=1

	for site in "${sites[@]}"
	do
		if [ "${sites[$i]}" == "" ]; then
			echo $i
			return 0
		fi

		i=$((i+1))
	done

	echo $i
	return 0
}

function add_node()
{
	if [ -z "$1" ]; then
		color_msg 31 "No arguments. Please input at least 'user@ip'."
		exit 1
	fi

	num=$(find_insert_num)

	echo -e

	while true; do
		echo -n "Add this node to position "
		color_msg 32 "[$num] " -n
		read -p "(y/n)" yn

		case $yn in
			[Yy]* ) add_node_to_num "$num" "$1" "$2";;
			[Nn]* ) read -p "Input your number:" un
					add_node_to_num $un "$1" "$2";;
			* ) echo "Please answer y or a number you want to add";;
		esac

		if [ $? -eq 0 ]; then
			break
		fi
	done
}

# Display author information
function display_author()
{
	color_msg 38 "This utility is created by " -n
	color_msg 36 "Vincent Shi-Ming Huang."
	color_msg 38 "If you have any problem or you hit some issue/bug, please send your comment to " -n
	color_msg 36 "Vincent.SM.Huang@gmail.com"
	color_msg 38 "http://vincent-smh.appspot.com"
}

# Display the usage of 'cn' command
function display_usage()
{
	echo -e
	color_msg 38 "Usage: cn " -n
	color_msg 32 "<num|l|r|a|d|s|rn>" -n
	color_msg 33 " [args]"
	color_msg 38 "   - " -n
	color_msg 32 "num" -n
	color_msg 38 ": SSH to site #num."
	color_msg 38 "          ex. cn 2"
	color_msg 38 "          ex. cn 3 -X (with X-forwarding)"

	color_msg 38 "   - " -n
	color_msg 32 "l" -n
	color_msg 38 ": list all sites."

	color_msg 38 "   - " -n
	color_msg 32 "r" -n
	color_msg 38 ": Register public key to site #num. "
	color_msg 38 "        ex: cn r 3 password"

	color_msg 38 "   - " -n
	color_msg 32 "a" -n
	color_msg 38 ": Add a new site."
	color_msg 38 "        ex: cn a user@127.0.0.1 \"Description of the site.\""
	color_msg 38 "        ex: cn a \"-p 2222 user@127.0.0.1 \"Description of the site.\" (Assign a port)"

	color_msg 38 "   - " -n
	color_msg 32 "d" -n
	color_msg 38 ": Delete a site (num). "
	color_msg 38 "        ex: cn d 3"

	display_scp

	color_msg 38 "   - " -n
	color_msg 32 "rn" -n
	color_msg 38 ": reorder the number of all sites."

	display_move_usage
	echo -e
	display_author
	echo -e
}

# Delete the given node
function del_node()
{
	if [ -z "$2" ]; then
		display_site

		echo -e
		color_msg 38 "Usage: conn d [num1 num2 num3 ...]"
		exit 0
	fi

	shift 1
	i=0

	# Find indexes of the deleting site
	for num in $@
	do
		unset sites[$num]
	done

	export_to_file
}

function check_python()
{
	check=`whereis python | grep -c bin`
	if [ "$check" == "0" ]; then
		color_msg 31 "Please install \"python\" before you use this function."
		exit 0
	fi
}

function renumber_sites()
{
	i=1

	for site in "${sites[@]}"
	do
		node_idx="node$i"
		field2=$(echo $site | awk -F "_" {'print $2'})
		field3=$(echo $site | awk -F "_" {'print $3'})
		tmp_sites[$i]="$node_idx"_"$field2"_"$field3"
		i=$(($i+1))
	done

	unset sites
	sites=("${tmp_sites[@]}")
	unset tmp_sites

	export_to_file
}

function display_move_usage()
{
	color_msg 38 "   - " -n
	color_msg 32 "m" -n
	color_msg 38 ": Move a site #num1 to #num2"
	color_msg 38 "        ex: cn m 10 3"
}

# Recursively move $1 to $2
# Input:
#   $1->original site number
#   $2->site number that will move to
#   $3->the site number which indicates the end of recursive moving
function move_function()
{
	if [ -z $3 ]; then
		display_move_usage
		exit 0
	fi

	id="node$2"
	field1=$(echo "${sites[$1]}" | awk -F "_" {'print $2'})
	field2=$(echo "${sites[$1]}" | awk -F "_" {'print $3'})

	# This will occurs when $1 > $2, we let $3 = $1 and this check is to limit
	# the movement stop at most on the position of $1.
	if [ $2 -eq $3 ]; then
		sites[$2]="$id"_"$field1"_"$field2"
		return 0
	fi

	# local variable for recursive call
	local site="$id"_"$field1"_"$field2"

	# Check if the dest site number is existed.
	if [ "${sites[$2]}" != "" ]; then
		move_function $2 $(($2+1)) $3
	fi

	# We have make sure the dest is empty or is moved to its next. So, we can
	# assign value to it (move over).
	sites[$2]="$site"

	# When $2 > $1, after we move $1 to its next, we have to unset its original
	# position
	if [ $2 -gt $1 ]; then
		unset sites[$1]
	fi
}

# function main()
if [ -z "$1" ]; then
	display_usage
else
	read_sites

	case "$1" in
		[l] )
			echo -e
			display_site
			exit 0;;
		[a] )
			add_node "$2" "$3"
			display_site
			exit 0;;
		[d] )
			del_node $@
			display_site
			exit 0;;
		[s] )
			scp_function $@
			exit 0;;
		[r] )
			check_python
			reg_key $2 $3
			exit 0;;
		[m] )
			move_function $2 $3 $2
			export_to_file
			display_site
			exit 0;;
		rn )
			renumber_sites
			display_site
			exit 0;;
	esac

	userip=$(find_userip "$1")
	check_n_exit $? "[$1] does not exist"
	ssh $2 $userip
fi
